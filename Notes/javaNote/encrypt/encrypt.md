#### ASCII 码
#### Unicode码 
```$xslt
  (Unicode码转utf-8)编码规则如下：
  Unicode 十六进制码点范围	    UTF-8 二进制
  0000 0000 - 0000 007F	    0xxxxxxx
  0000 0080 - 0000 07FF	    110xxxxx 10xxxxxx
  0000 0800 - 0000 FFFF	    1110xxxx 10xxxxxx 10xxxxxx
  0001 0000 - 0010 FFFF	    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
  根据上面编码规则对照表，进行 UTF-8 编码和解码就简单多了。下面以汉字“汉”为利，具体说明如何进行 UTF-8 编码和解码。
  “汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），通过上面的对照表可以发现，0x0000 6c49 位于
  第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后
  向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001
  10001001，转换成十六进制就是 0xE6 0xB7 0x89。
  解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续
  有多少个 1，就表示该字符占用多少个字节。
  Unicode码(一个汉字占二个字节)
  UTF-8格式(一个汉字占二个字节)
```
#### URL编码  
 - URL编码是编码算法，不是加密算法 
 - URL编码是对字符进行编码   
       URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：
       https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87
#### Base64编码
 - Base64编码是对二进制数据进行编码，表示成文本格式  
 - 原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。
### hash算法(验证原始数据是否被篡改，存储用户口令)
```$xsit
    哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。
    哈希算法最重要的特点就是：
        相同的输入一定得到相同的输出；
        不同的输入大概率得到不同的输出。
    哈希算法的目的就是为了验证原始数据是否被篡改。
                另一个重要用途是存储用户口令
    加盐(salt): 防止彩虹表(同样的输入，添加了盐值，会产生不同的输出。会使之前的彩虹表失效)
```
 ### BouncyCastle
  - 是一个提供了很多哈希算法和加密算法的第三方库(提供了java标准库没有的一些算法 例如，RipeMD160哈希算法。)
 ### Hmac 算法(相当于hash算法加盐salt)
  - 一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法
  - Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。
# 数据加密
 ### 对称加密
   - 对称加密算法就是传统的用一个密码进行加密和解密
   ```aidl
    常用的对称加密算法有
    算法	    密钥长度	     工作模式     	        填充模式
    DES	    56/64	      ECB/CBC/PCBC/CTR/...	NoPadding/PKCS5Padding/...
    AES	    128/192/256	  ECB/CBC/PCBC/CTR/...	NoPadding/PKCS5Padding/PKCS7Padding/...
    IDEA	    128	          ECB	                PKCS5Padding/PKCS7Padding/...
   ```
   - DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了
   - AES(对称加密必须指定秘钥长度)
     - ECB :    
         指定秘钥长度，简单的通过秘钥进行加密解密 (相对简单，不推荐使用)
     - CBC :    
         指定秘钥长度，通过秘钥和随机生成的IV参数 进行加密解密  
 ### 口令加密(内部使用的还是对称加密算法)
   - PBE算法，采用随机数杂凑计算出真正的密钥;     
     - PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥(类似于对称加密的CBC模式)
     - 加密和解密需要口令和一个外在的salt，相当于把秘钥拆分成了口令和salt(案例：银行U盾)
     ```aidl
        PBE算法通过用户口令和安全的随机salt计算出Key，然后再进行加密；
        Key通过口令和安全的随机salt计算得出，大大提高了安全性；
        PBE算法内部使用的仍然是标准对称加密算法（例如AES）。
     ```
 ### 秘钥交换算法（DH算法）
   -  DH算法是一种密钥交换协议，通信双方通过不安全的信道协商密钥，然后进行对称加密传输。
      DH算法没有解决中间人攻击。
 ### 非对称加密 (RSA算法)
   - 非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。
   ```
   在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：
   
   小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；
   小红用自己的RSA私钥解密得到AES口令；
   双方使用这个共享的AES口令用AES加密通信。
   可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器
   先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。
   ```   
  - 非对称加密，通过交换公钥，用公钥加密真正的AES口令，将该加密之后的口令发送给对方，
             对方通过自己的私钥解密得到AES 口令，再用AES加密通信
  - 小结：[[使用非对称加密来加密对称加密使用的秘钥。不需要对称加密的双方协商秘钥]];
 ### 数字签名
   - 私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证，
     使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。
     
## 签名算法和数字证书的关系
```aidl
  
对称加密：加密和解密的密钥一样，比如用123加密就是用123解密，但是实际中密码都是普通数据在互联网传输的，这样一点密码被中间人截取并破解，
加密直接被攻破。
非对称加密：把密钥分为公钥和私钥，公钥是公开的所有人都可以认领，私钥是保密的只有一个人知道。假设A要发送一封Email给B，他不想让任何
其他人在传输中看到Email的内容，做法就是使用B的公钥对Email加密，只有B的私钥能够解密（B的私钥唯一性保证信件不会泄露）。
某天出意外了，有黑客冒充A给B发送Email，并且也用B的公钥加密，导致B无法区分这封邮件是否来自A。怎么办？此时A可以用自己的私钥加密，
那么B收到邮件后如果用A的公钥可以解密邮件，那么证明这封信肯定来自于A。
OK，通过这个例子我想你们基本明白非对称加密了！
我总结了下面几点：
公钥的作用：对内容本身加密，保证不被其他人看到。
私钥的作用：证明内容的来源
公钥和私钥是配对关系，公钥加密就用私钥解密，反之亦然，用错的密钥来尝试解密会报错。

 [[案例：发送email(签名算法和数字证书) ]]
                    A                                            B     
 1            对Email哈希得到hash值，                      4    用A的公钥对数字签名验签，通过说明数据是A发出的。得到步骤1的hash
 2            用自己的私钥加密hash值，得到数字签名。           5    对原数据进行hash,与步骤4的hash对比，
 3            把数字签名和email用公钥加密。发送给B            6    步骤4通过说明数据是A发出的，步骤5 通过说明数据没有被更改
                                                        7    A的公钥有被替换的风险：
                                                              CA认证：证书中心用自己的私钥对A的公钥进行加密，生成数字证书，A在邮件正文下方除了数字签名，另外加上这张数字证书，
                                                              B收到Email后用CA的公钥解密这份数字证书，拿到A的公钥，然后验证数字签名
1.A先对这封Email执行哈希运算得到hash值简称“摘要”，取名h1
2.然后用自己私钥对摘要加密，生成的东西叫“数字签名”
3.把数字签名加在Email正文后面，一起发送给B
（当然，为了防止邮件被窃听你可以用继续公钥加密，这个不属于数字签名范畴）
4.B收到邮件后用A的公钥对数字签名解密，成功则代表Email确实来自A，失败说明有人冒充
5.B对邮件正文执行哈希运算得到hash值，取名h2
6.B 会对比第4步数字签名的hash值h1和自己运算得到的h2，一致则说明邮件未被篡改。

```